{% extends "base.html" %}
{% import "bootstrap/wtf.html" as wtf %}

{% block title %}Traffiway - Find the best way{% endblock %}

{% block page_content %}

    <div>
        {% if current_user %}
            {{ wtf.quick_form(form) }}
        {% endif %}
    </div>

    <div>
        {% if response %}
            <p>{{ start_point }}</p><br/>
            <p>{{ next_point }}</p><br/>
            <p>{{ response }}</p>
            <p>{{ start_dict }}</p>
            <p>{{ next_dict }}</p>
        {% endif %}
    </div>

    <div style="width: 640px; height: 480px" id="mapContainer"></div>

    <script>
      // Initialize the platform object:
      var platform = new H.service.Platform({
        'apikey': 'Wtz4pThMbs_tIMzmaBfNlIIB39uWirtBfi55snakm-M'
      });

      // Retrieve the target element for the map:
      var targetElement = document.getElementById('mapContainer');

      // Obtain the default map types from the platform object
      var maptypes = platform.createDefaultLayers();

      // Instantiate (and display) a map object:
      var map = new H.Map(
        document.getElementById('mapContainer'),
        maptypes.vector.normal.map,
        {
          zoom: 10,
          //center: { lng: 13.4, lat: 52.51 }
        });

      // Adding the flow layer available in the default layer collection to the map
      //map.addLayer(defaultLayers.vector.normal.traffic);

      // Enable the event system on the map instance:
      var mapEvents = new H.mapevents.MapEvents(map);

      // Add event listener:
      map.addEventListener('tap', function(evt) {
        // Log 'tap' and 'mouse' events:
        console.log(evt.type, evt.currentPointer.type);

        // Instantiate the default behavior, providing the mapEvents object:
        var behavior = new H.mapevents.Behavior(mapEvents);


        // Create the default UI:
        var ui = H.ui.UI.createDefault(map, maptypes, 'en-US');
        var mapSettings = ui.getControl('mapsettings');
        var zoom = ui.getControl('zoom');
        var scalebar = ui.getControl('scalebar');

        mapSettings.setAlignment('top-left');
        zoom.setAlignment('top-left');






        //MARKERS
        {#// Define a variable holding SVG mark-up that defines an icon image:#}
        {#var svgMarkup = '<svg width="24" height="24" ' +#}
        {#    'xmlns="http://www.w3.org/2000/svg">' +#}
        {#    '<rect stroke="white" fill="#1b468d" x="1" y="1" width="22" ' +#}
        {#    'height="22" /><text x="12" y="18" font-size="12pt" ' +#}
        {#    'font-family="Arial" font-weight="bold" text-anchor="middle" ' +#}
        {#    'fill="white">H</text></svg>';#}


        {#var avoid_centres = {{ danger_list_center|safe }};#}
        {#var array_centres = avoid_centres.split('|'),#}
        {#  warn1 = array_centres[0], warn2 = array_centres[1], warn3 = array_centres[3];#}
        {##}
        {#var warn1_geo = warn1.split(','), warn1_lat=warn1_geo[0], warn1_lng=warn1[1]#}

        {#// Create an icon, an object holding the latitude and longitude, and a marker:#}
        {#var icon = new H.map.Icon(svgMarkup),#}
        {#    coords = {lat: warn1_lat, lng: warn1_lng},#}
        {#    marker = new H.map.Marker(coords, {icon: icon});#}
        {##}
        {#// Add the marker to the map and center the map at the location of the marker:#}
        {#map.addObject(marker);#}

          var geocodingParams = {
          searchText: 'Warszawa, Polaka 3'
        };

          var onResult = function(result) {
          var locations = result.Response.View[0].Result,
              position,
              marker;
          // Add a marker for each location found
          for (i = 0;  i < locations.length; i++) {
            position = {
              lat: locations[i].Location.DisplayPosition.Latitude,
              lng: locations[i].Location.DisplayPosition.Longitude
            };
            marker = new H.map.Marker(position);
            map.addObject(marker);
          }
        };

        // Get an instance of the geocoding service:
        var geocoder = platform.getGeocodingService();

        // Call the geocode method with the geocoding parameters,
        // the callback and an error callback function (called if a
        // communication error occurs):
        geocoder.geocode(geocodingParams, onResult, function(e) {
          alert(e);
});


});


      var time_from_start1 = {{ time_from_start1|safe }};
      var time_from_start2 = {{ time_from_start2|safe }};
      var time_from_start3 = {{ time_from_start3|safe }};
      var localization_counter = {{ localization_counter|safe }};

      var start_point_positions = {{ start_point_positions|safe }};
 //     var next_point_positions = {{ next_point_positions|safe }};
//      var next_point_positions2 = {{ next_point_positions2|safe }};
  //    var next_point_positions3 = {{ next_point_positions3|safe }};

      if (localization_counter === 1) {
          var next_point_positions = {{ next_point_positions|safe }};
      }

      if (localization_counter === 2) {
        if (time_from_start1 < time_from_start2) {
          var next_point_positions = {{ next_point_positions|safe }};
          var next_point_positions2 = {{ next_point_positions2|safe }};
        } else if (time_from_start1 > time_from_start2){
          var next_point_positions = {{ next_point_positions2|safe }};
          var next_point_positions2 = {{ next_point_positions|safe }};
        }
      }

      if (localization_counter === 3) {
          if (time_from_start1 < time_from_start2 && time_from_start1 < time_from_start3) {
              var next_point_positions = {{ next_point_positions|safe }};
              if (time_from_start2 < time_from_start3) {
                  var next_point_positions2 = {{ next_point_positions2|safe }};
                  var next_point_positions3 = {{ next_point_positions3|safe }};
              } else if (time_from_start2 > time_from_start3) {
                  var next_point_positions2 = {{ next_point_positions3|safe }};
                  var next_point_positions3 = {{ next_point_positions2|safe }};
              }
          } else if (time_from_start2 < time_from_start1 && time_from_start2 < time_from_start3) {
              var next_point_positions = {{ next_point_positions2|safe }};
              if (time_from_start1 < time_from_start3) {
                  var next_point_positions2 = {{ next_point_positions|safe }};
                  var next_point_positions3 = {{ next_point_positions3|safe }};
              } else if (time_from_start1 > time_from_start3) {
                  var next_point_positions2 = {{ next_point_positions3|safe }};
                  var next_point_positions3 = {{ next_point_positions|safe }};
              }
          } else if (time_from_start3 < time_from_start1 && time_from_start3 < time_from_start2) {
              var next_point_positions = {{ next_point_positions3|safe }};
              if (time_from_start1 < time_from_start2) {
                  var next_point_positions2 = {{ next_point_positions|safe }};
                  var next_point_positions3 = {{ next_point_positions2|safe }};
              } else if (time_from_start1 > time_from_start2) {
                  var next_point_positions2 = {{ next_point_positions2|safe }};
                  var next_point_positions3 = {{ next_point_positions|safe }};
              }
          }
      }







      var next_point_positions4 = {{ next_point_positions4|safe }};
      var next_point_positions5 = {{ next_point_positions5|safe }};
      var next_point_positions6 = {{ next_point_positions6|safe }};


      var avoid_areas = {{ danger_list|safe }};

      if (localization_counter === 1) {
          var routingParameters = {
              // The routing mode:
              'mode': 'fastest;car',
              // The start point of the route:
              'waypoint0': 'geo!' + start_point_positions,
              // The end point of the route:
              'waypoint1': 'geo!' + next_point_positions,
              // To retrieve the shape of the route we choose the route
              // representation mode 'display'
              'representation': 'display',
              // areas which transport should avoid
              'avoidareas': avoid_areas
              };
      } else if (localization_counter === 2) {
          var routingParameters = {
              // The routing mode:
              'mode': 'fastest;car',
              // The start point of the route:
              'waypoint0': 'geo!' + start_point_positions,
              // The end point of the route:
              'waypoint1': 'geo!' + next_point_positions,
              'waypoint2': 'geo!' + next_point_positions2,
              // To retrieve the shape of the route we choose the route
              // representation mode 'display'
              'representation': 'display',
              // areas which transport should avoid
              'avoidareas': avoid_areas
              };
      } else if (localization_counter === 3) {
          var routingParameters = {
              // The routing mode:
              'mode': 'fastest;car',
              // The start point of the route:
              'waypoint0': 'geo!' + start_point_positions,
              // The end point of the route:
              'waypoint1': 'geo!' + next_point_positions,
              'waypoint2': 'geo!' + next_point_positions2,
              'waypoint3': 'geo!' + next_point_positions3,
              // To retrieve the shape of the route we choose the route
              // representation mode 'display'
              'representation': 'display',
              // areas which transport should avoid
              'avoidareas': avoid_areas
              };
      } else if (localization_counter === 4) {
          var routingParameters = {
              // The routing mode:
              'mode': 'fastest;car',
              // The start point of the route:
              'waypoint0': 'geo!' + start_point_positions,
              // The end point of the route:
              'waypoint1': 'geo!' + next_point_positions,
              'waypoint2': 'geo!' + next_point_positions2,
              'waypoint3': 'geo!' + next_point_positions3,
              'waypoint4': 'geo!' + next_point_positions4,
              // To retrieve the shape of the route we choose the route
              // representation mode 'display'
              'representation': 'display',
              // areas which transport should avoid
              'avoidareas': avoid_areas
              };
      } else if (localization_counter === 5) {
          var routingParameters = {
              // The routing mode:
              'mode': 'fastest;car',
              // The start point of the route:
              'waypoint0': 'geo!' + start_point_positions,
              // The end point of the route:
              'waypoint1': 'geo!' + next_point_positions,
              'waypoint2': 'geo!' + next_point_positions2,
              'waypoint3': 'geo!' + next_point_positions3,
              'waypoint4': 'geo!' + next_point_positions4,
              'waypoint5': 'geo!' + next_point_positions5,
              // To retrieve the shape of the route we choose the route
              // representation mode 'display'
              'representation': 'display',
              // areas which transport should avoid
              'avoidareas': avoid_areas
              };
      } else if (localization_counter === 6) {
          var routingParameters = {
              // The routing mode:
              'mode': 'fastest;car',
              // The start point of the route:
              'waypoint0': 'geo!' + start_point_positions,
              // The end point of the route:
              'waypoint1': 'geo!' + next_point_positions,
              'waypoint2': 'geo!' + next_point_positions2,
              'waypoint3': 'geo!' + next_point_positions3,
              'waypoint4': 'geo!' + next_point_positions4,
              'waypoint5': 'geo!' + next_point_positions5,
              'waypoint6': 'geo!' + next_point_positions6,
              // To retrieve the shape of the route we choose the route
              // representation mode 'display'
              'representation': 'display',
              // areas which transport should avoid
              'avoidareas': avoid_areas
              };
      }


      // Define a callback function to process the routing response:
    var onResult = function(result) {
        var route,
            routeShape,
            startPoint,
            endPoint,
            linestring;

        if (result.response.route) {
            // Pick the first route from the response:
            route = result.response.route[0];
            // Pick the route's shape:
            routeShape = route.shape;

            // Create a linestring to use as a point source for the route line
            linestring = new H.geo.LineString();

            // Push all the points in the shape into the linestring:
            routeShape.forEach(function (point) {
                var parts = point.split(',');
                linestring.pushLatLngAlt(parts[0], parts[1]);
            });

            // Retrieve the mapped positions of the requested waypoints:
            if (localization_counter === 1) {
                startPoint = route.waypoint[0].mappedPosition;
                endPoint = route.waypoint[1].mappedPosition;
                            // Create a marker for the start point:
                var startMarker = new H.map.Marker({
                    lat: startPoint.latitude,
                    lng: startPoint.longitude
                });

                // Create a marker for the end point:
                var endMarker = new H.map.Marker({
                    lat: endPoint.latitude,
                    lng: endPoint.longitude
                });
            } else if (localization_counter === 2) {
                startPoint = route.waypoint[0].mappedPosition;
                medPoint1 = route.waypoint[1].mappedPosition;
                endPoint = route.waypoint[2].mappedPosition;
                            // Create a marker for the start point:
                var startMarker = new H.map.Marker({
                    lat: startPoint.latitude,
                    lng: startPoint.longitude
                });

                // Create a marker for the medium point:
                var medMarker1 = new H.map.Marker({
                    lat: medPoint1.latitude,
                    lng: medPoint1.longitude
                });

                // Create a marker for the end point:
                var endMarker = new H.map.Marker({
                    lat: endPoint.latitude,
                    lng: endPoint.longitude
                });
            } else if (localization_counter === 3) {
                startPoint = route.waypoint[0].mappedPosition;
                medPoint1 = route.waypoint[1].mappedPosition;
                medPoint2 = route.waypoint[2].mappedPosition;
                endPoint = route.waypoint[3].mappedPosition;
                            // Create a marker for the start point:
                var startMarker = new H.map.Marker({
                    lat: startPoint.latitude,
                    lng: startPoint.longitude
                });

                // Create a marker for the medium point:
                var medMarker1 = new H.map.Marker({
                    lat: medPoint1.latitude,
                    lng: medPoint1.longitude
                });

                // Create a marker for the medium point:
                var medMarker2 = new H.map.Marker({
                    lat: medPoint2.latitude,
                    lng: medPoint2.longitude
                });

                // Create a marker for the end point:
                var endMarker = new H.map.Marker({
                    lat: endPoint.latitude,
                    lng: endPoint.longitude
                });
            } else if (localization_counter === 4) {
                startPoint = route.waypoint[0].mappedPosition;
                medPoint1 = route.waypoint[1].mappedPosition;
                medPoint2 = route.waypoint[2].mappedPosition;
                medPoint3 = route.waypoint[3].mappedPosition;
                endPoint = route.waypoint[4].mappedPosition;
                            // Create a marker for the start point:
                var startMarker = new H.map.Marker({
                    lat: startPoint.latitude,
                    lng: startPoint.longitude
                });

                // Create a marker for the medium point:
                var medMarker1 = new H.map.Marker({
                    lat: medPoint1.latitude,
                    lng: medPoint1.longitude
                });

                // Create a marker for the medium point:
                var medMarker2 = new H.map.Marker({
                    lat: medPoint2.latitude,
                    lng: medPoint2.longitude
                });

                // Create a marker for the medium point:
                var medMarker3 = new H.map.Marker({
                    lat: medPoint3.latitude,
                    lng: medPoint3.longitude
                });

                // Create a marker for the end point:
                var endMarker = new H.map.Marker({
                    lat: endPoint.latitude,
                    lng: endPoint.longitude
                });
            } else if (localization_counter === 5) {
                startPoint = route.waypoint[0].mappedPosition;
                medPoint1 = route.waypoint[1].mappedPosition;
                medPoint2 = route.waypoint[2].mappedPosition;
                medPoint3 = route.waypoint[3].mappedPosition;
                medPoint4 = route.waypoint[4].mappedPosition;
                endPoint = route.waypoint[5].mappedPosition;
                            // Create a marker for the start point:
                var startMarker = new H.map.Marker({
                    lat: startPoint.latitude,
                    lng: startPoint.longitude
                });

                // Create a marker for the medium point:
                var medMarker1 = new H.map.Marker({
                    lat: medPoint1.latitude,
                    lng: medPoint1.longitude
                });

                // Create a marker for the medium point:
                var medMarker2 = new H.map.Marker({
                    lat: medPoint2.latitude,
                    lng: medPoint2.longitude
                });

                // Create a marker for the medium point:
                var medMarker3 = new H.map.Marker({
                    lat: medPoint3.latitude,
                    lng: medPoint3.longitude
                });

                // Create a marker for the medium point:
                var medMarker4 = new H.map.Marker({
                    lat: medPoint4.latitude,
                    lng: medPoint4.longitude
                });

                // Create a marker for the end point:
                var endMarker = new H.map.Marker({
                    lat: endPoint.latitude,
                    lng: endPoint.longitude
                });
            } else if (localization_counter === 6) {
                startPoint = route.waypoint[0].mappedPosition;
                medPoint1 = route.waypoint[1].mappedPosition;
                medPoint2 = route.waypoint[2].mappedPosition;
                medPoint3 = route.waypoint[3].mappedPosition;
                medPoint4 = route.waypoint[4].mappedPosition;
                medPoint5 = route.waypoint[5].mappedPosition;
                endPoint = route.waypoint[6].mappedPosition;
                            // Create a marker for the start point:
                var startMarker = new H.map.Marker({
                    lat: startPoint.latitude,
                    lng: startPoint.longitude
                });

                // Create a marker for the medium point:
                var medMarker1 = new H.map.Marker({
                    lat: medPoint1.latitude,
                    lng: medPoint1.longitude
                });

                // Create a marker for the medium point:
                var medMarker2 = new H.map.Marker({
                    lat: medPoint2.latitude,
                    lng: medPoint2.longitude
                });

                // Create a marker for the medium point:
                var medMarker3 = new H.map.Marker({
                    lat: medPoint3.latitude,
                    lng: medPoint3.longitude
                });

                // Create a marker for the medium point:
                var medMarker4 = new H.map.Marker({
                    lat: medPoint4.latitude,
                    lng: medPoint4.longitude
                });

                // Create a marker for the medium point:
                var medMarker5 = new H.map.Marker({
                    lat: medPoint5.latitude,
                    lng: medPoint5.longitude
                });

                // Create a marker for the end point:
                var endMarker = new H.map.Marker({
                    lat: endPoint.latitude,
                    lng: endPoint.longitude
                });
            }

            // Create a polyline to display the route:
            //var routeLine = new H.map.Polyline(linestring, {
            //style: {strokeColor: 'blue', lineWidth: 3}
            //});


            // Create an outline for the route polyline:
            var routeOutline = new H.map.Polyline(linestring, {
              style: {
                lineWidth: 10,
                strokeColor: 'rgba(0, 128, 255, 0.7)',
                lineTailCap: 'arrow-tail',
                lineHeadCap: 'arrow-head'
              }
            });
            // Create a patterned polyline:
            var routeArrows = new H.map.Polyline(linestring, {
              style: {
                lineWidth: 10,
                fillColor: 'white',
                strokeColor: 'rgba(255, 255, 255, 1)',
                lineDash: [0, 2],
                lineTailCap: 'arrow-tail',
                lineHeadCap: 'arrow-head' }
              }
            );

            // create a group that represents the route line and contains
            // outline and the pattern
            var routeLine = new H.map.Group();
            routeLine.addObjects([routeOutline, routeArrows]);

            if (localization_counter === 1) {
               // Add the route polyline and the two markers to the map:
                map.addObjects([routeLine, startMarker, endMarker]);
            } else if (localization_counter === 2) {
                // Add the route polyline and the two markers to the map:
                map.addObjects([routeLine, startMarker, endMarker, medMarker1]);
            } else if (localization_counter === 3) {
                // Add the route polyline and the two markers to the map:
                map.addObjects([routeLine, startMarker, endMarker, medMarker1, medMarker2]);
            } else if (localization_counter === 4) {
                // Add the route polyline and the two markers to the map:
                map.addObjects([routeLine, startMarker, endMarker, medMarker1, medMarker2, medMarker3]);
            } else if (localization_counter === 5) {
                // Add the route polyline and the two markers to the map:
                map.addObjects([routeLine, startMarker, endMarker, medMarker1, medMarker2, medMarker3, medMarker4]);
            } else if (localization_counter === 6) {
                // Add the route polyline and the two markers to the map:
                map.addObjects([routeLine, startMarker, endMarker, medMarker1, medMarker2, medMarker3, medMarker4, medMarker5]);
            }


            // Set the map's viewport to make the whole route visible:
            map.getViewModel().setLookAtData({bounds: routeLine.getBoundingBox()});

        }
    };

    // Get an instance of the routing service:
    var router = platform.getRoutingService();

    // Call calculateRoute() with the routing parameters,
    // the callback and an error callback function (called if a
    // communication error occurs):
    router.calculateRoute(routingParameters, onResult,
      function(error) {
        alert(error.message);
      });

    </script>


    <script type="text/javascript" src='js/map.js'></script>

{% endblock %}